<div id="root"></div>
<script>
function generateHTML(jsonTree, rootElement) {
    function createElementFromJSON(jsonNode) {
        // Base case: handle text nodes
        if (jsonNode.tagName === '#text') {
            return document.createTextNode(jsonNode.innerText);
        }

        if (! jsonNode.tagName) {
            jsonNode.tagName = 'root';
        }
        // Create the element for the current tag
        const element = document.createElement(jsonNode.tagName);

        // Apply attributes if they exist
        if (jsonNode.attributes) {
            jsonNode.attributes.forEach(attr => {
                element.setAttribute(attr.name, attr.value);
            });
        }

        // Recursively append child elements
        if (jsonNode.children) {
            jsonNode.children.forEach(child => {
                const childElement = createElementFromJSON(child);
                element.appendChild(childElement);
            });
        }

        return element;
    }

    const domTree = createElementFromJSON(jsonTree);
    if (domTree.tagName === 'ROOT') {
        while (domTree.firstChild) {
            rootElement.appendChild(domTree.firstChild);
        }
    } else {
        rootElement.appendChild(domTree);
    }

    return rootElement;
}

function HTMLParser(html) {

    /**
     * Check if is a self-closing tag
     * @param tagName
     * @returns {boolean}
     */
    function isSelfClosing(tagName) {
        // List of self-closing or void HTML elements
        const selfClosingTags = [
            'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'source', 'track', 'wbr'
        ];

        // Convert tagName to lowercase to ensure case-insensitive comparison
        return selfClosingTags.includes(tagName.toLowerCase());
    }

    /**
     * Handle the text node
     */
    const commitText = function() {
        if (this.text) {
            if (! this.current.children) {
                this.current.children = [];
            }
            this.current.children.push({
                tagName: '#text',
                innerText: this.text,
                parent: this.current,
            });

            delete this.text;
        }
    }

    /**
     * Save the attribute to the tag
     */
    const commitAttribute = function() {
        if (this.tag.attributeName) {
            // Commit any current attribute
            if (! this.tag.attributes) {
                this.tag.attributes = [];
            }

            let k = this.tag.attributeName;
            let v = this.tag.attributeValue;

            if (typeof(v) === 'undefined') {
                v = k;
            }

            this.tag.attributes.push({
                name: k,
                value: v,
            });

            delete this.tag.attributeName;
            delete this.tag.attributeValue;

            if (this.tag.attributeIsReadyToClose) {
                delete this.tag.attributeIsReadyToClose;
            }
        }
    }

    /**
     * Find the parent node
     * @param node
     * @param tagName
     * @returns {*}
     */
    const findParentByTagName = function(node, tagName) {
        if (node) {
            if (node.tagName === tagName) {
                return node;
            } else {
                return findParentByTagName(node.parent, tagName);
            }
        }
    }

    /**
     * Actions controller
     * @param control
     * @param char
     */
    let actions = function(control, char) {
        let method = control.action || 'text';
        actions[method].call(control, char);
    };

    /**
     * Process a new tag
     * @param char
     */
    actions.processTag = function(char) {
        // Just to check if there are any text to commit
        commitText.call(this);

        // Process the tag
        if (char === '<') {
            // Create new tag
            this.tag = {
                tagName: '',
                parent: this.current
            };
        } else if (char.match(/[a-zA-Z0-9-]/)) {
            // Tag name
            this.tag.tagName += char;
        } else {
            // Finished with tag name, move to attribute handling
            this.action = 'attributeName';
        }
    }

    /**
     * Handle tag closing
     * @param char
     */
    actions.closeTag = function(char) {
        // Make sure to commit attribute
        commitAttribute.call(this);
        // Close the tag
        if (char === '>') {
            // Get the new parent
            if (isSelfClosing(this.tag.tagName)) {
                // Push new tag to the parent
                if (! this.tag.parent.children) {
                    this.tag.parent.children = [];
                }
                this.tag.parent.children.push(this.tag);
            } else if (this.tag.closingTag) {
                // Need to find the parent on the chain
                let ret = findParentByTagName(this.tag.parent, this.tag.tagName);
                if (ret) {
                    this.current = ret.parent;
                }
            } else {
                if (this.tag.closing) {
                    // Current is the parent
                    this.current = this.tag.parent;
                } else {
                    this.current = this.tag;
                }

                // Push new tag to the parent
                if (! this.tag.parent.children) {
                    this.tag.parent.children = [];
                }
                this.tag.parent.children.push(this.tag);
            }

            // Finalize tag
            this.tag = null;
            // New action
            this.action = 'text';
        } else {
            if (! this.tag.locked) {
                if (char === '/') {
                    if (! this.tag.tagName) {
                        // This is a closing tag
                        this.tag.closingTag = true;
                    }
                    // Closing character is found
                    this.tag.closing = true;
                } else if (char.match(/[a-zA-Z0-9-]/)) {
                    // If is a closing tag, get the tag name
                    if (this.tag.closingTag) {
                        this.tag.tagName += char;
                    }
                } else {
                    // Wait to the closing sign
                    if (this.tag.tagName) {
                        this.locked = true;
                    }
                }
            }
        }

    }

    actions.attributeName = function(char) {
        // There is another attribute to commit
        if (this.tag.attributeIsReadyToClose) {
            commitAttribute.call(this);
        }

        // Build attribute name
        if (char.match(/[a-zA-Z0-9-:]/)) {
            if (! this.tag.attributeName) {
                this.tag.attributeName = '';
            }
            this.tag.attributeName += char;
        } else if (char === '=') {
            // Move to attribute value
            if (this.tag.attributeName) {
                this.action = 'attributeValue';
                delete this.tag.attributeIsReadyToClose;
            }
        } else if (char.match(/\s/)) {
            this.tag.attributeIsReadyToClose = true;
        }
    };

    actions.attributeValue = function(char) {
        if (! this.tag.attributeValue) {
            this.tag.attributeValue = '';
        }

        if (char === '"' || char === "'") {
            if (this.tag.insideQuote) {
                if (this.tag.insideQuote === char) {
                    this.tag.insideQuote = false;
                } else {
                    this.tag.attributeValue += char;
                }
            } else {
                this.tag.insideQuote = char;
            }
        } else {
            // Inside quotes, keep appending to the attribute value
            if (this.tag.insideQuote) {
                this.tag.attributeValue += char;
            } else if (char.match(/\s/)) {
                if (this.tag.attributeValue) {
                    this.action = 'attributeName';
                }
                this.tag.attributeIsReadyToClose = true;
            } else {
                if (this.tag.attributeIsReadyToClose) {
                    this.action = 'attributeName';
                    actions.attributeName.call(this, char);
                } else {
                    this.tag.attributeValue += char;
                }
            }
        }
    }

    actions.text = function(char) {
        if (! this.text) {
            this.text = '';
        }
        this.text += char; // Keep appending to text content
    };

    let result = { tagName: 'root' };
    let control = {
        current: result,
        action: 'text'
    };

    // Main loop to process the HTML string
    for (let i = 0; i < html.length; i++) {
        let char = html[i];

        // Global control logic
        if (control.tag) {
            if (char === '>' || char === '/') {
                // End of tag, commit any attributes and go back to text parsing
                if (! control.tag.insideQuote) {
                    control.action = 'closeTag';
                }
            }
        } else {
            if (char === '<') {
                control.action = 'processTag';
            }
        }
        actions(control, char);
    }

    return result;
}

function testHTMLTransformation(inputHTML) {

    function compareDOMTrees(node1, node2) {
        // Compare node types (element vs. text)
        if (node1.nodeType !== node2.nodeType) return false;

        // Compare tag names (case-insensitive)
        if (node1.nodeType === 1 && node2.nodeType === 1) {
            if (node1.tagName.toLowerCase() !== node2.tagName.toLowerCase()) {
                return false;
            }

            // Compare attributes (handle boolean attributes)
            const booleanAttributes = [
                'allowfullscreen',
                'async',
                'autofocus',
                'autoplay',
                'checked',
                'controls',
                'default',
                'defer',
                'disabled',
                'formnovalidate',
                'inert',
                'ismap',
                'itemscope',
                'loop',
                'multiple',
                'muted',
                'nomodule',
                'novalidate',
                'open',
                'playsinline',
                'readonly',
                'required',
                'reversed',
                'selected',
            ];

            const attrs1 = node1.attributes;
            const attrs2 = node2.attributes;

            const normalizedAttrs1 = Array.from(attrs1).reduce((acc, attr) => {
                if (booleanAttributes.includes(attr.name)) {
                    acc[attr.name] = node1.hasAttribute(attr.name);
                } else {
                    acc[attr.name] = attr.value;
                }
                return acc;
            }, {});

            const normalizedAttrs2 = Array.from(attrs2).reduce((acc, attr) => {
                if (booleanAttributes.includes(attr.name)) {
                    acc[attr.name] = node2.hasAttribute(attr.name);
                } else {
                    acc[attr.name] = attr.value;
                }
                return acc;
            }, {});

            // Compare the length of attributes
            if (Object.keys(normalizedAttrs1).length !== Object.keys(normalizedAttrs2).length) {
                return false;
            }

            // Compare each attribute
            for (let key in normalizedAttrs1) {
                if (normalizedAttrs1[key] !== normalizedAttrs2[key]) {
                    return false;
                }
            }
        }

        // Compare text content if it's a text node
        if (node1.nodeType === 3 && node2.nodeType === 3) {
            if (node1.textContent.trim() !== node2.textContent.trim()) {
                return false;
            }
        }

        // Compare children recursively (ignoring order)
        const children1 = Array.from(node1.childNodes);
        const children2 = Array.from(node2.childNodes);

        // Compare children count
        if (children1.length !== children2.length) return false;

        // Compare children nodes structurally
        for (let i = 0; i < children1.length; i++) {
            if (!compareDOMTrees(children1[i], children2[i])) {
                return false;
            }
        }

        return true;
    }

    // Step 1: Parse the input HTML into a JSON structure using your parser
    const parsedJSON = HTMLParser(inputHTML);

    // Step 2: Create the root element
    const rootElement = document.createElement('div');

    // Step 3: Convert the JSON back to DOM and append it to the root element
    generateHTML(parsedJSON, rootElement);

    // Step 4: Get the output DOM after transformation
    const outputDOM = rootElement;

    // Step 5: Create a reference DOM by parsing the input HTML into an element
    const referenceDOM = document.createElement('div');

    referenceDOM.innerHTML = inputHTML
        .replace(/(<(([A-Z]{1}|[a-z]*-){1}[a-zA-Z0-9_-]+)[^>]*)(\/|\/.{1})>/gm, "$1></$2>")
        .replace(/<>/gi, "<root>")
        .replace(/<\/>/gi, "<\/root>")
        .trim();

    console.log("Output DOM: ", outputDOM.firstChild.outerHTML);
    console.log("Reference DOM: ", referenceDOM.firstChild.outerHTML);

    // Step 6: Compare the generated DOM tree with the reference DOM tree
    return compareDOMTrees(outputDOM.firstChild, referenceDOM.firstChild);
}

//console.log(HTMLParser(`<aa><div disabled>test</div><Test title="aaa" :onclick="test" /><h1>sadf</h1><Modal><b>test test test</b></Modal></aa>`))
//console.log(testHTMLTransformation(`<div disabled :title="{{self.title}}" onclick="self.click">test <b>aaaa</b><br><br/><br>test<img src="test"/></div><Test title=aaa /><h1>sadf</h1>`))
//console.log(testHTMLTransformation(`<div disabled :title="{{self.title}}" onclick="self.click">test <p><div>adsf<b>asdf</div><lm-modal>test132</lm-modal><b>aaaa</b><br><br/><br>test<img src="test"/></div><Test title=aaa /><h1>sadf</h1>`))
console.log(testHTMLTransformation(`<div><div title="<" a b test='>'>test<b></b></div>test</div>`))

</script>